<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>improved main page</title>
  <style>
    #loader-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #222;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 2000;
    }

    .loader {
      width: 60px;
      aspect-ratio: 1;
      background:
        linear-gradient(90deg, #ffffff 50%, #2758e2 0) top/100% 50% no-repeat,
        linear-gradient(90deg, #3abef9 50%, #fb6222 0);
      -webkit-mask: linear-gradient(#000 0 0) 0 0/50% 50% no-repeat;
      mask: linear-gradient(#000 0 0) 0 0/50% 50% no-repeat;
      animation: l18 2s infinite;
    }

    @keyframes l18 {
      0%   { -webkit-mask-position: 0 0 }
      25%  { -webkit-mask-position: 100% 0 }
      50%  { -webkit-mask-position: 100% 100% }
      75%  { -webkit-mask-position: 0 100% }
      100% { -webkit-mask-position: 0 0 }
    }

    @font-face {
      font-family: 'MinecraftRegular';
      src: url('../font/MinecraftRegular.otf') format('opentype');
    }

    .minecraft-text {
      font-family: 'MinecraftRegular', monospace;
      font-size: 30px;
      width: 50%;
      height: auto;
      position: absolute;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: #ffffff;
      z-index: 10;
      pointer-events: none;
    }

    html, body {
      height: 100%;
      margin: 0;
      scroll-behavior: smooth;
      overflow: hidden;
    }

    .scroll-container {
      height: 100vh;
      overflow-y: scroll;
      scroll-snap-type: y mandatory;
      scrollbar-width: none;
      -ms-overflow-style: none;
    }

    .page {
      height: 100vh;
      scroll-snap-align: start;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
      justify-content: center;
      align-items: center;
    }

    .background {
      position: absolute;
      width: 101vw;
      height: 101vh;
      top: -5px;
      left: -5px;
      background: url("../images/sky.gif") center/cover no-repeat;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: -2;
      will-change: background-position;
    }

    .wave, .bottom-img, .beneath-img {
      position: absolute;
      bottom: -75px;
      left: -10vw;
      width: 120vw;
      height: 120vh;
      object-fit: cover;
      pointer-events: none;
      transform: translateX(-50%);
      will-change: transform;
      z-index: -1;
    }

    #title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 10;
      width: 100vw;
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 0.4s ease, transform 0.4s ease;
      pointer-events: none;
    }

    #container {
      position: relative;
      perspective: 800px;
      justify-content: center;
      align-items: center;
      display: inline-block;
      max-width: 90vw;
      max-height: 70vh;
      z-index: 10;
      width: 60vw;
      min-width: 220px;
    }

    .img-layer {
      position: absolute;
      width: 100%;
      max-width: 100vw;
      height: auto;
      transform-origin: center;
      will-change: transform;
    }

    #shadowImg { z-index: 0; }
    #mainImg { z-index: 1; position: relative; }

    .bottom-images, .beneath-images {
      position: absolute;
      width: 100vw;
      height: 100vh;
      left: 0;
      top: 0;
      pointer-events: none;
      z-index: 0;
    }

    @media (max-width: 700px) {
      #container { width: 85vw; max-width: 60vh; }
    }

    @media (max-width: 450px) {
      #container { width: 98vw; max-width: 40vh; }
    }

    #loader-gif {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: transparent;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1999;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s;
    }
  </style>
</head>
<body>
  <div id="loader-wrapper"><div class="loader"></div></div>
  <div id="loader-gif">
    <img src="../images/Loader.gif" alt="Loading..." style="width: 100vw; height: 100vh;" data-duration="1785">
  </div>

  <div class="scroll-container">
    <section class="page page1">
      <div class="background" aria-hidden="true"></div>
      <a id="mlh-trust-badge" style="display:block;max-width:100px;min-width:60px;position:absolute;right:50px;top:0;width:10%;z-index:100" href="https://mlh.io/na?utm_source=na-hackathon&utm_medium=TrustBadge&utm_campaign=2026-season&utm_content=white" target="_blank"><img src="https://s3.amazonaws.com/logged-assets/trust-badge/2026/mlh-trust-badge-2026-white.svg" alt="Major League Hacking 2026 Hackathon Season" style="width:100%"></a>
      <img class="wave" id="wave1" src="../images/wave1.png" loading="lazy">
      <img class="wave" id="wave2" src="../images/wave2.gif" loading="lazy">
      <img class="wave" id="wave3" src="../images/wave3.gif" loading="lazy">
      <img class="wave" id="wave4" src="../images/wave4.gif" loading="lazy">
      <div id="title" role="banner">
        <div id="container">
          <img id="shadowImg" class="img-layer" src="../images/shadow.png" loading="lazy">
          <img id="mainImg" class="img-layer" src="../images/title.png" loading="lazy">
        </div>
      </div>
    </section>

    <section class="page page2">
      <div id="about" role="banner" style="top:20%; left:50%; transform:translate(-50%,-25%); position:absolute; z-index:10; width:25vw; display:flex; justify-content:center; align-items:center; pointer-events:none;">
        <div id="about-container" style="position:relative; perspective:800px; justify-content:center; align-items:center; display:inline-block; max-width:90vw; width:60vw; min-width:220px;">
          <img id="aboutShadow" class="img-layer" src="../images/about shadow.png" loading="lazy" style="z-index:0;">
          <img id="aboutMain" class="img-layer" src="../images/about.png" loading="lazy" style="z-index:1; position:relative;">
        </div>
      </div>

      <p class="minecraft-text">
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
        The quick fox jump over the lazy dogs.
      </p>

      <div class="beneath-images">
        <img class="beneath-img" id="beneath1" src="../images/Beneath1.gif" loading="lazy" style="z-index: 5;">
        <img class="beneath-img" id="beneath2" src="../images/Light.png" loading="lazy" 
        style="z-index: 4; width: 40vw; left: 10vw; top: 10vh; opacity: 0.5;">
        <img class="beneath-img" id="beneath3" src="../images/Beneath2.gif" loading="lazy" style="z-index: 3;">
        <img class="beneath-img" id="beneath4" src="../images/Beneath3.gif" loading="lazy" style="z-index: 2;">
        <img class="beneath-img" id="beneath5" src="../images/Light2.png" loading="lazy" 
        style="z-index: 2; width: 40vw; left: 70vw; top: 10vh; opacity: 0.7;">
        <img class="beneath-img" id="beneath6" src="../images/Light3.png" loading="lazy" 
        style="z-index: 1; width: 20vw; left: 50vw; top: 10vh; opacity: 0.6;">
        <img class="beneath-img" id="beneath7" src="../images/Beneath4.png" loading="lazy" style="z-index: 0;">
      </div>
    </section>

    <section class="page page3">
      <div class="bottom-images">
        <img class="bottom-img" id="bottom5" src="../images/bottom5.png" loading="lazy" style="z-index: 0;">
        <img class="bottom-img" id="bottom4" src="../images/bottom4.png" loading="lazy" style="z-index: 1;">
        <img class="bottom-img" id="bottom3" src="../images/bottom3.png" loading="lazy" style="z-index: 2;">
        <img class="bottom-img" id="bottom2" src="../images/bottom2.gif" loading="lazy" style="z-index: 3;">
        <img class="bottom-img" id="bottom1" src="../images/bottom1.gif" loading="lazy" style="z-index: 4;">
      </div>
    </section>
  </div>
<script>
    document.addEventListener('DOMContentLoaded', () => {
        // Cache DOM elements
        const bg = document.querySelector('.background');
        const waves = document.querySelectorAll('.wave');
        const container = document.getElementById('container');
        const mainImg = document.getElementById('mainImg');
        const shadowImg = document.getElementById('shadowImg');
        const title = document.getElementById('title');
        const scrollContainer = document.querySelector('.scroll-container');
        const loaderGif = document.getElementById('loader-gif');
        const loaderGifImg = loaderGif?.querySelector('img');
        const aboutContainer = document.getElementById('about-container');
        const aboutMain = document.getElementById('aboutMain');
        const aboutShadow = document.getElementById('aboutShadow');
        
        // Cache styles for performance
        const bgStyle = bg.style;
        const mainImgStyle = mainImg.style;
        const shadowImgStyle = shadowImg.style;
        const titleStyle = title.style;
        const loaderGifStyle = loaderGif?.style;

        // Movement and animation variables
        const moveFactors = [0.0005, 0.005, 0.01, 0.05, 0.1, 0.15, 0.2];
  let centerX = window.innerWidth * 0.5;
  let centerY = window.innerHeight * 0.5;
        let box = null;
        let aboutbox = null;
        let lastX = centerX, lastY = centerY;
        let isAnimating = true;

        // Cache bottom and beneath images with their styles
        const bottomImgs = [];
        const beneathImgs = [];
        
        for (let i = 1; i <= 5; i++) {
            const img = document.getElementById(`bottom${i}`);
            if (img) bottomImgs.push({el: img, style: img.style});
        }
        
        for (let i = 1; i <= 7; i++) {
            const img = document.getElementById(`beneath${i}`);
            if (img) beneathImgs.push({el: img, style: img.style});
        }

        // Optimized box update
        function updateBox() { 
            box = container.getBoundingClientRect(); 
        }

        function updateAboutBox() {
            // keep same naming as the outer-scope variable (aboutbox)
            if (aboutContainer) aboutbox = aboutContainer.getBoundingClientRect();
        }

        if (aboutMain) aboutMain.addEventListener('load', updateAboutBox);
        window.addEventListener('resize', () => setTimeout(updateAboutBox, 16));
                  
        mainImg.addEventListener('load', updateBox);
        let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        updateBox();
        // refresh viewport center used for pointer math
        centerX = window.innerWidth * 0.5;
        centerY = window.innerHeight * 0.5;
        // also update about box when resizing
        updateAboutBox();
      }, 16);
    });

    // Throttled pointer movement for parallax effects
    // add a tiny early-out to ignore duplicate pointer events
    let pointerMoveQueued = false;
    let lastPointerEventX = null;
    let lastPointerEventY = null;
    function onPointerMove(e) {
      // ignore identical consecutive events (common on some touchpads)
      if (e.clientX === lastPointerEventX && e.clientY === lastPointerEventY) return;
      lastPointerEventX = e.clientX;
      lastPointerEventY = e.clientY;

      if (pointerMoveQueued) return;
      pointerMoveQueued = true;

      requestAnimationFrame(() => {
        // apply the most recently seen pointer coordinates
        lastX = lastPointerEventX;
        lastY = lastPointerEventY;
        pointerMoveQueued = false;
      });
    }

    window.addEventListener('pointermove', onPointerMove, {passive: true});

    // Optimized animation loop
    // add a light FPS cap to reduce CPU on idle/fast-noticeable updates
    const TARGET_FPS = 30; // conservative target preserves smoothness
    const FRAME_INTERVAL = 1000 / TARGET_FPS;
    let lastFrameTime = performance.now();

    function animate(now) {
      if (!isAnimating) return;
      if (!now) now = performance.now();
      const elapsed = now - lastFrameTime;
      if (elapsed < FRAME_INTERVAL) {
        // skip this frame but keep the loop alive
        requestAnimationFrame(animate);
        return;
      }
      // account for any drift
      lastFrameTime = now - (elapsed % FRAME_INTERVAL);

      // Update parallax effects
      if (box) {
                const offsetX = lastX - centerX;
                const offsetY = lastY - centerY;
                
                // Background parallax (use numeric factors for both axes)
                bgStyle.backgroundPosition = `${-offsetX * moveFactors[0]}px ${-offsetY * moveFactors[0]}px`;
                
                // Wave parallax
                waves.forEach((wave, i) => {
                    const tx = offsetX * (moveFactors[i]+0.05);
                    const ty = offsetY * (moveFactors[i]+0.05);
                    wave.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
                });

                // Bottom images parallax
                bottomImgs.forEach((imgObj, i) => {
                    const factor = moveFactors[moveFactors.length - 1 - i];
                    const tx = offsetX * factor * 0.75;
                    const ty = offsetY * factor * 0.75;
                    imgObj.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
                });

                // Beneath images parallax
                beneathImgs.forEach((imgObj, i) => {
                    const factor = moveFactors[moveFactors.length - 1 - i];
                    const tx = offsetX * factor * 1.1;
                    const ty = offsetY * factor * 1.1;
                    imgObj.style.transform = `translate3d(${tx}px, ${ty}px, 0)`;
                });

                // 3D tilt effect
                const centerBx = box.left + box.width * 0.5;
                const centerBy = box.top + box.height * 0.5;
                const dx = lastX - centerBx;
                const dy = lastY - centerBy;
                const percentX = dx / (box.width * 0.5);
                const percentY = dy / (box.height * 0.5);
                
                const rotateX = (-percentY * 15);
                const rotateY = (percentX * 15);
                const scale = 1 + ((Math.abs(percentX) + Math.abs(percentY)) * 0.5) * 0.1;
                
                mainImgStyle.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(${scale}, ${scale}, 1)`;
                
                const shadowScale = scale * 1.07;
                const offsetX2 = percentX * 10;
                const offsetY2 = percentY * 10;
                shadowImgStyle.transform = `translate3d(${offsetX2}px, ${offsetY2}px, 0) rotateX(${rotateX}deg) rotateY(${rotateY}deg) scale3d(${shadowScale}, ${shadowScale}, 1)`;

        // About section 3D tilt effect (calculate relative to viewport center)
        if (aboutbox) {
          // Compute deviation from viewport center (neutral point)
          const vdx = lastX - centerX;
          const vdy = lastY - centerY;

          // Normalize by half viewport size so values are roughly in [-1,1]
          const halfW = window.innerWidth * 0.5 || 1;
          const halfH = window.innerHeight * 0.5 || 1;
          let apercentX = vdx / halfW;
          let apercentY = vdy / halfH;

          // Clamp to avoid extreme flips
          apercentX = Math.max(-1, Math.min(1, apercentX));
          apercentY = Math.max(-1, Math.min(1, apercentY));

          // Reduce strength slightly so the about tilt is subtler
          const strength = 0.6;
          const arotateX = (-apercentY * 15 * strength);
          const arotateY = (apercentX * 15 * strength);
          const ascale = 1 + ((Math.abs(apercentX) + Math.abs(apercentY)) * 0.5) * 0.05;

          aboutMain.style.transform = `rotateX(${arotateX}deg) rotateY(${arotateY}deg) scale3d(${ascale}, ${ascale}, 1)`;

          const ashadowScale = ascale * 1.07;
          const aoffsetX2 = apercentX * 8;
          const aoffsetY2 = apercentY * 8;
          aboutShadow.style.transform = `translate3d(${aoffsetX2}px, ${aoffsetY2}px, 0) rotateX(${arotateX}deg) rotateY(${arotateY}deg) scale3d(${ashadowScale}, ${ashadowScale}, 1)`;
        }
            }
            
      requestAnimationFrame(animate);
        }
        
        // Start animation
        requestAnimationFrame(animate);

        // Reset on blur
        window.addEventListener('blur', () => {
            mainImgStyle.transform = '';
            shadowImgStyle.transform = '';
        });

        // Loader GIF management
        const loaderGifDuration = parseInt(loaderGifImg?.dataset.duration) || 1200;
        let currentGifSrc = '';

        function showLoaderGif() {
            if (!loaderGif || !loaderGifImg) return;
            
            if (loaderGifStyle.opacity !== '1') {
                // Refresh GIF by changing src
                if (!currentGifSrc) currentGifSrc = loaderGifImg.src;
                loaderGifImg.src = currentGifSrc + '?t=' + Date.now();
                
                loaderGifStyle.opacity = '1';
                loaderGifStyle.pointerEvents = 'auto';
            }
        }

        function hideLoaderGif() {
            if (loaderGif && loaderGifStyle.opacity !== '0') {
                loaderGifStyle.opacity = '0';
                loaderGifStyle.pointerEvents = 'none';
            }
        }

        // Optimized scroll handling
        let pendingScroll = 0;
        let isDelayingScroll = false;
        let scrollTimeoutId = null;
        const scrollDelay = 500;


    // Improved wheel/touchpad handling: one page per gesture
    (function installWheelPager(){
      const pages = document.querySelectorAll('.page');
      const pageCount = pages.length;
      const scrollLockDuration = 700; // ms - lock while smooth scroll animates

      scrollContainer.addEventListener('wheel', (e) => {
        // We control the scroll behavior here
        e.preventDefault();

        // Ignore tiny/no movement
        if (!e.deltaY) return;

        // If a scroll is already in progress, ignore further wheel events
        if (isDelayingScroll) return;

        // Determine direction: 1 = down, -1 = up
        const direction = e.deltaY > 0 ? 1 : -1;

        // Determine current page and clamp target
        const currentPage = Math.round(scrollContainer.scrollTop / window.innerHeight || 0);
        let targetPage = currentPage + direction;
        if (targetPage < 0) targetPage = 0;
        if (targetPage > pageCount - 1) targetPage = pageCount - 1;

        // If no page change, do nothing
        if (targetPage === currentPage) return;

        isDelayingScroll = true;

        // Show animation/loader first, then start smooth scroll on the next frame
        showLoaderGif();
        // ensure the CSS transition for the loader starts before scrolling
        requestAnimationFrame(() => {
          // small timeout to give the browser a chance to paint the loader
          setTimeout(() => {
            scrollContainer.scrollTo({ top: targetPage * window.innerHeight, behavior: 'smooth' });
            // hide loader after estimated duration but keep lock until scroll completes
            setTimeout(() => {
              hideLoaderGif();
            }, Math.min(loaderGifDuration, 600));
          }, 30);
        });

        // release lock after estimated scroll duration
        setTimeout(() => {
          isDelayingScroll = false;
        }, scrollLockDuration);

      }, { passive: false });
    })();

        // Optimized scroll position tracking
        let scrollTicking = false;
        const vh = window.innerHeight;
        
        function onScroll() {
            if (scrollTicking) return;
            scrollTicking = true;
            
            requestAnimationFrame(() => {
                const scrollY = scrollContainer.scrollTop;
                
                if (scrollY < vh) {
                    titleStyle.opacity = '1';
                    titleStyle.transform = 'translate(-50%, -50%)';
                } else if (scrollY < vh * 2) {
                    const progress = (scrollY - vh) / vh;
                    titleStyle.opacity = 1 - 0.5 * progress;
                    titleStyle.transform = 'translate(-50%, -50%)';
                } else {
                    titleStyle.opacity = '0.5';
                    titleStyle.transform = 'translate(-50%, -100vh)';
                }
                
                scrollTicking = false;
            });
        }
        
  scrollContainer.addEventListener('scroll', onScroll, {passive: true});
  onScroll();
  updateBox();
  // initialize about bounding box so the about tilt works immediately
  updateAboutBox();
    });

    // Optimized window load handler
    window.addEventListener('load', () => {
        const loader = document.getElementById('loader-wrapper');
        const loaderGif = document.getElementById('loader-gif');

        if (!loader) {
            document.body.classList.remove('loading-bg');
            return;
        }

        // Show loader GIF after 500ms
        const showGifTimer = setTimeout(() => {
            if (loaderGif) {
                loaderGif.style.opacity = '1';
                loaderGif.style.pointerEvents = 'auto';
            }
        }, 500);

        // Hide main loader after 1000ms
        const hideLoaderTimer = setTimeout(() => {
            loader.style.opacity = '0';
            
            const removeLoaderTimer = setTimeout(() => {
                loader.remove();
                
                const finalCleanupTimer = setTimeout(() => {
                    if (loaderGif) {
                        loaderGif.style.opacity = '0';
                        loaderGif.style.pointerEvents = 'none';
                    }
                    document.body.classList.remove('loading-bg');
                }, 120);
            }, 500);
        }, 1000);
    });
</script>
</body>
</html>